недавнего
времени
появилась
настойчивая
мысль
профессиональное
развитие
сильно
замедлилось
хочется
как-то
исправить
читаю
книги
слушаю
курсы
время
приходит
понимание
возможно
пришло
время
сменить
работу
здесь
вроде
изучено
плавно
уходим
рутину
Данная
мысль
сподвигла
рассылку
своего
резюме
несколько
компаний
лидеров
рынка
После
прохождения
собеседования
решил
водится
внести
копеек
освещение
обширной
собеседования
именно
технических
вопросов
коллекциям
которыми
приходится
сталкиваться
читатель
скажет
коллекции
избитая
сколько
можно
часть
приведенных
вопросов
задавал
своим
знакомым
разработчикам
которые
занимают
именно
позиции
разработчиков
крепких
середнячков
меркам
недалекой
Москвы
глубинки
которые
уверенно
справляются
своей
работой
практике
теории
скажем
пробелы
потому
работа
требует
решения
каких-то
нетривиальных
задач
потому
интересно
изучать
внутри
работает
структура
данных
вызывало
растерянность
Думаю
рассмотренный
материал
будет
очень
интересен
разработчикам
уровня
Junior
попрошу
комментировать
дополнять
критиковать
изложенный
здесь
материал
Junior`ы
уверен
найдут
статье
интересное
Признаюсь
честно
прохождении
интервью
ответы
некоторые
изложенных
вопросов
вроде
прошел
джуниорства
вдвойне
обидно
учетом
позиции
компании
симпатию
вызывало
начиная
общения
заканчивая
возможной
будущей
сферой
деятельности
удалось
получить
оффер
вопросы
коллекциям
которыми
справился
уверен
внесли
негативную
лепту
прошло
вполне
неплохо
точки
зрения
собеседования
предложенная
сфера
деятельности
общение
целом
будущими
коллегами
оставили
негатив
закон
подлости
красе
итоге
данным
топиком
своей
голове
заполнить
обнаруженные
бумаге
знания
статье
рассмотрю
только
вопросы
вызвавшие
сложности
последних
собеседованиях
вопросы
которые
задавали
практику
прохождения
собеседований
думаю
переходить
вопросам
отличается
ArrayList
LinkedList
рейтинге
самых
популярных
вопросов
коллекции
задают
случаев
Вызвал
проблему
первом
собеседовании
Junior
Developer`а
Вкратце
ответ
вопрос
сводится
следующему
ArrayList
список
реализованный
основе
массива
LinkedList
классический
связный
список
основанный
объектах
ссылками
между
Преимущества
ArrayList
возможности
доступа
произвольному
элементу
индексу
постоянное
время
массив
минимум
накладных
расходов
хранении
такого
списка
вставка
конец
списка
среднем
производится
постоянное
время
среднем
потому
массив
имеет
определенный
начальный
размер
параметр
capacity
умолчанию
записи
элемента
будет
создан
новый
массив
размером
будут
помещены
элементы
старого
массива
новый
добавляемый
элемент
итоге
получаем
добавлении
элемента
необходимости
расширения
массива
время
добавления
будет
значительно
больше
нежели
записи
элемента
готовую
пустую
ячейку
менее
среднем
время
вставки
элемента
конец
списка
является
постоянным
Удаление
последнего
элемента
происходит
константное
время
Недостатки
ArrayList
проявляются
вставке/удалении
элемента
середине
списка
взывает
перезапись
элементов
размещенных
правее
списке
позицию
влево
кроме
удалении
элементов
размер
массива
уменьшается
явного
вызова
метода
trimToSize
LinkedList
наоборот
постоянное
время
может
выполнять
вставку/удаление
элементов
списке
именно
вставку
удаление
поиск
позиции
вставки
удаления
входит
Доступ
произвольному
элементу
осуществляется
линейное
время
доступ
первому
последнему
элементу
списка
всегда
осуществляется
константное
время
ссылки
постоянно
хранятся
первый
последний
добавление
элемента
конец
списка
вовсе
значит
придется
перебирать
список
поисках
последнего
элемента
целом
LinkedList
абсолютных
величинах
проигрывает
ArrayList
потребляемой
памяти
скорости
выполнения
операций
LinkedList
предпочтительно
применять
когда
происходит
активная
работа
серединой
списка
случаях
когда
необходимо
гарантированное
время
добавления
элемента
список
углубленного
время
экспресс
обучения
очень
рекомендую
прочтению
замечательные
статьи
tarzan82
ArrayList
LinkedList
порекомендую
статью
потреблении
памяти
коллекциями
очень
познавательно
обычно
используете
ArrayList
LinkedList
Почему
вопрос
является
слегка
замаскированной
версией
предыдущего
ответ
вопрос
приведет
постепенному
изложению
ответа
предыдущей
вопрос
случае
ArrayList
будет
быстрее
экономичнее
LinkedList
обычно
используют
ArrayList
менее
всегда
случаев
LinkedList
говорю
обычно
ArrayList
использую
ссылаясь
тесты
последний
абзац
предыдущего
вопроса
забываю
LinkedList
каких
случаях
последний
абзац
предыдущего
вопроса
помогает
быстрее
работает
ArrayList
LinkedList
замаскированная
версия
первого
вопроса
Хитрее
приведенных
вариантов
постановка
вопроса
подразумевает
односложный
ответ
выбором
одного
предложенных
вариантов
задумке
автора
вопроса
понимаю
должно
сразу
выявить
человека
неглубокими
познаниями
collections
Правильным
действием
будет
встречный
вопрос
какие
действия
будут
выполняться
структурой
итоге
диалог
плавно
переходит
ответу
первый
вопрос
Необходимо
добавить
элемент
какую
структуру
используете
довольно
популярная
скрытая
версия
первого
вопроса
постановка
предполагает
выбор
одного
предложенных
вариантов
самом
информации
однозначного
выбора
Нужно
задавать
дополнительные
вопросы
какую
часть
списка
происходит
добавление
элементов
информация
потом
будет
происходить
элементами
списка
какие
ограничения
памяти
скорости
выполнения
целом
первый
вопрос
немного
другой
стороны
через
дополнительные
вопросы
показываете
глубину
понимания
работы
Array
Linked
Однажды
клюнул
крючок
домыслив
добавить
вставить
конец
списка
усиленно
продвигал
ArrayList
ничего
пытался
узнать
дальнейшие
действие
списком
возможные
ограничения
происходит
удаление
элементов
ArrayList
меняется
случае
размер
ArrayList
Опять
ответ
вопрос
содержит
ответ
вопрос
удалении
произвольного
элемента
списка
элементы
находящиеся
правее
смещаются
ячейку
влево
реальный
размер
массива
емкость
capacity
изменяется
никак
Механизм
автоматического
расширения
массива
существует
автоматического
сжатия
можно
только
выполнить
сжатие
командой
trimToSize
Предложите
эффективный
алгоритм
удаления
нескольких
рядом
стоящих
элементов
середины
списка
реализуемого
ArrayList
Неизбитый
меркам
вопрос
встречался
всего
однажды
когда
механизма
удаления
элементов
ArrayList
итоге
вызвал
серьезные
затруднения
самом
довольно
просто
очевидно
когда
знаешь
происходит
удаление
одного
элемента
Допустим
нужно
удалить
элементов
позиции
списке
Вместо
выполнения
удаления
одного
элемента
каждый
смещая
позицию
элементы
стоящие
правее
списке
нужно
выполнить
смещение
элементов
стоящих
правее
позиции
элементов
левее
началу
списка
Таким
образом
вместо
выполнения
итераций
перемещения
элементов
списка
выполняется
проход
устроена
HashMap
второй
списка
самых
популярных
вопросов
коллекциям
помню
случай
когда
вопрос
задавали
Вкратце
HashMap
состоит
корзин
bucket`ов
технической
точки
зрения
корзины
элементы
массива
которые
хранят
ссылки
списки
элементов
добавлении
новой
ключ-значение
вычисляет
хеш-код
ключа
основании
которого
вычисляется
номер
корзины
номер
ячейки
массива
которую
попадет
новый
элемент
корзина
пустая
сохраняется
ссылка
вновь
добавляемый
элемент
элемент
происходит
последовательный
переход
ссылкам
между
элементами
цепочке
поисках
последнего
элемента
которого
ставится
ссылка
вновь
добавленный
элемент
списке
найден
элемент
таким
ключом
заменяется
Добавление
поиск
удаление
элементов
выполняется
константное
время
Вроде
здорово
одной
оговоркой
хеш-функций
должна
равномерно
распределять
элементы
корзинам
случае
временная
сложность
операций
будет
среднем
случае
константное
время
целом
этого
ответа
вполне
хватит
поставленный
вопрос
дальше
скорее
всего
завяжется
диалог
HashMap
углубленным
пониманием
процессов
тонкостей
Опять
рекомендую
прочтению
статью
tarzan82
HashMap
Какое
начальное
количество
корзин
HashMap
Довольно
неожиданный
вопрос
опять
когда-то
заставил
угадывать
число
корзин
использовании
конструктора
умолчанию
Ответ
здесь
Отвечая
стоит
заметить
можно
используя
конструкторы
параметрами
через
параметр
capacity
задавать
начальное
количество
корзин
Какая
оценка
временной
сложности
выборки
элемента
HashMap
Гарантирует
HashMap
указанную
сложность
выборки
элемента
Ответ
первую
часть
вопроса
можно
найти
ответе
вопрос
константное
время
необходимо
выборки
элемента
второй
части
вопроса
недавно
растерялся
устройство
HashMap
хеш-функцию
такому
вопросу
готов
кинулся
вообще
другом
направлении
сосредоточился
строении
HashMap
откинув
проблему
хеш-кода
который
голове
всегда
привык
считать
хеш-кодом
равномерным
распределением
самом
ответ
довольно
простой
следует
ответа
вопроса
возьмете
хеш-функцию
которая
постоянно
будет
возвращать
значение
HashMap
превратится
связный
список
отвратной
Затем
будете
использовать
хеш-функцию
равномерным
распределением
предельном
случае
гарантироваться
будет
только
временная
сложность
ответ
вторую
часть
вопроса
гарантируется
equals
hashCode
HashMap
Ответ
вопрос
следует
ответа
вопрос
прописан
hashCode
позволяет
определить
корзину
поиска
элемента
equals
используется
сравнения
ключей
элементов
списке
внутри
корзины
искомого
ключа
Максимальное
число
значений
hashCode
Здесь
довольно
просто
достаточно
вспомнить
сигнатуру
метода
hashCode
число
значений
равно
диапазону
точного
диапазона
никогда
спрашивали
хватало
такого
ответа
когда
происходит
увеличение
количества
корзин
HashMap
довольно
тонкий
вопрос
показал
мини-опрос
устройства
HashMap
представляют
многие
более-менее
вопрос
часто
ставил
собеседника
тупик
Помимо
capacity
HashMap
параметр
loadFactor
основании
которого
вычисляется
предельное
количество
занятых
корзин
умолчанию
loadFactor
достижению
предельного
значения
число
корзин
увеличивается
хранимых
элементов
вычисляется
новое
местоположение
учетом
нового
числа
корзин
каком
случае
может
потерян
элемент
HashMap
интересный
вопрос
прислал
LeoCcoder
подобного
спрашивали
честно
признаюсь
после
прочтения
сходу
придумать
сценарий
потери
элемента
опять
оказалось
довольно
просто
явно
допустим
качестве
ключа
используется
примитив
объект
несколькими
полями
После
добавления
элемента
HashMap
объекта
который
выступает
качестве
ключа
изменяют
которое
участвует
вычислении
хеш-кода
результате
попытке
найти
данный
элемент
исходному
ключу
будет
происходить
обращение
правильной
корзине
equals
ведь
equals
hashCode
должны
работать
одним
набором
полей
найдет
указанный
списке
элементов
менее
equals
реализован
таким
образом
изменение
данного
объекта
влияет
результат
после
увеличения
размера
корзин
пересчета
хеш-кодов
элементов
указанный
элемент
измененным
значением
большой
долей
вероятности
попадет
совсем
другую
корзину
тогда
совсем
потеряется
Почему
нельзя
использовать
byte[]
качестве
ключа
HashMap
вопрос
LeoCcoder
обычно
оказалось
довольно
просто
хеш-код
массива
зависит
хранимых
элементов
присваивается
создании
массива
метод
вычисления
хеш-кода
массива
переопределен
вычисляется
стандартному
ObjecthashCode
основании
адреса
массива
массивов
переопределен
equals
выполняет
сравнение
указателей
приводит
обратиться
сохраненному
ключом-массивом
элементу
получится
использовании
другого
массива
такого
размера
такими
элементами
доступ
можно
осуществить
одном
случае
использовании
самой
ссылки
массив
использовалась
сохранения
элемента
ответ
вопрос
отдельная
благодарность
уходит
пользователю
@dark_dimius
отличия
TreeSet
HashSet
Начнем
множество
называют
набором
допускает
хранение
одинаковых
элементов
Формально
говоря
термин
множество
обозначает
совокупность
различных
элементов
очень
важно
именно
различных
элементов
главное
свойство
учетом
такого
определения
пояснение
хранение
одинаковых
элементом
требуется
обиходе
понятие
множество
потеряло
строгий
смысл
касательно
уникальности
элементов
входящих
поэтому
уточняйте
отдельно
данное
свойство
множества
TreeSet
обеспечивает
упорядоченно
хранение
элементов
красно-черного
дерева
Сложность
выполнения
основных
операций
TreeSet
HashSet
использует
хранения
элементов
такой
подход
HashMap
отличием
HashSet
качестве
ключа
выступает
элемент
кроме
HashSet
HashMap
поддерживает
упорядоченное
хранение
элементов
обеспечивает
временную
сложность
выполнения
операций
аналогично
HashMap
Устройство
TreeSet
вопрос
задают
вместо
вопроса
здесь
достаточно
краткого
ответа
TreeSet
основан
красно-черном
дереве
правило
этого
хватает
собеседник
сразу
переходит
следующему
вопросу
спрашивали
механизм
балансировки
дерева
другие
подробности
реализации
экспресс
углубления
знаний
красно-черному
дереву
рекомендую
статью
будет
добавлять
элементы
TreeSet
возрастанию
Обычно
данный
вопрос
собеседник
предваряет
фразой
основе
TreeSet
лежит
бинарное
дерево
добавлять
элементы
возрастанию
будут
распределены
дереву
точного
представления
устройстве
TreeSet
общее
понимание
бинарное
дерево
дополнительно
уверяет
собеседник
данный
вопрос
может
привести
интересному
результату
элементы
после
доабвления
обычное
бинарное
дерево
будут
находится
одной
ветви
длиной
элементов
сводит
преимущества
такой
структуры
дерево
фактически
получается
список
самом
упоминалось
основе
TreeSet
лежит
красно-черное
дерево
которое
умеет
балансировать
итоге
TreeSet
равно
каком
порядке
добавляете
элементы
преимущества
структуры
данных
будут
сохраняться
Заключение
Надеюсь
рассмотренные
вопросы
будут
полезны
хабраюзерам
Прошу
простить
возможную
некоторую
наивность
приведенные
вопросы
требуют
такого
детального
рассмотрения
время
подобная
статья
серьезно
помогла
Уверен
статье
присутствуют
неточности
прошу
комментарии
кроме
надеюсь
более
опытные
товарищи
комментариях
будут
активно
делится
вопросами
своей
практики
статья
будет
благосклонно
принята
хабрасообществом
вполне
возможно
продолжение
обзора
технических
вопросов
собеседований
Немного
меркантильного
интереса
поиски
нового
места
работы
продолжаются
кто-то
хабраюзеров
процессе
поиска
разработчика
компанию
современным
подходом
разработке
интересными
задачами
просто
может
порекомендовать
присмотреться
какой-либо
подходящей
вакансии
благодарен
прошу
личку